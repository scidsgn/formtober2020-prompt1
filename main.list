# file opened: main.asm
  1   0000                  device ZXSPECTRUM128
  2   0000
  3   0000                  org $8000
  4   8000
  5   8000                  include "./lib/output.z80"
# file opened: ./lib/output.z80
  1+  8000              ;
  2+  8000              ; Title:	ZX Spectrum Standard Output Routines
  3+  8000              ; Author:	Dean Belfield
  4+  8000              ; Created:	29/07/2011
  5+  8000              ; Last Updated:	08/02/2020
  6+  8000              ;
  7+  8000              ; Requires:
  8+  8000              ;
  9+  8000              ; Modinfo:
 10+  8000              ;
 11+  8000              ; 02/07/2012:	Added Pixel_Address_Down and Pixel_Address_Up routines
 12+  8000              ; 04/07/2012:	Moved Clear_Screen to Screen_Buffer
 13+  8000              ; 08/02/2010:	Added Print_BC
 14+  8000              ;		Moved Clear_Screen into here (originally in screen_buffer.z80)
 15+  8000              ;		All output routines refactored to use HL for screen address
 16+  8000              ;		Added Fill_Attr routine
 17+  8000              ;
 18+  8000
 19+  8000              ; Simple clear-screen routine
 20+  8000              ; Uses LDIR to block clear memory
 21+  8000              ; A:  Colour to clear attribute block of memory with
 22+  8000              ;
 23+  8000 21 00 40     Clear_Screen:		LD HL,16384			; Start address of screen bitmap
 24+  8003 11 01 40     			LD DE,16385			; Address + 1
 25+  8006 01 00 18     			LD BC,6144			; Length of bitmap memory to clear
 26+  8009 36 00        			LD (HL),0			; Set the first byte to 0
 27+  800B ED B0        			LDIR				; Copy this byte to the second, and so on
 28+  800D 01 FF 02     			LD BC,767			; Length of attribute memory, less one to clear
 29+  8010 77           			LD (HL),A			; Set the first byte to A
 30+  8011 ED B0        			LDIR				; Copy this byte to the second, and so on
 31+  8013 C9           			RET
 32+  8014
 33+  8014              ; Fill a box of the screen with a solid colour
 34+  8014              ;  A: The colour
 35+  8014              ; HL: Address in the attribute map
 36+  8014              ;  C: Width
 37+  8014              ;  B: Height
 38+  8014              ;
 39+  8014 11 20 00     Fill_Attr:		LD DE,32
 40+  8017 E5           1:			PUSH HL
 41+  8018 C5           			PUSH BC
 42+  8019 77           2:			LD (HL), A
 43+  801A 2C           			INC L
 44+  801B 0D           			DEC C
 45+  801C 20 FB        			JR NZ, 2B
 46+  801E C1           			POP BC
 47+  801F E1           			POP HL
 48+  8020 19           			ADD HL,DE
 49+  8021 10 F4        			DJNZ 1B
 50+  8023 C9           			RET
 51+  8024
 52+  8024              ; Print String Data
 53+  8024              ; First two bytes of string contain X and Y char position, then the string
 54+  8024              ; Individual strings are terminated with 0xFE
 55+  8024              ; End of data is terminated with 0xFF
 56+  8024              ; IX: Address of string
 57+  8024              ;
 58+  8024 DD 6E 00     Print_String:		LD L,(IX+0)			; Fetch the X coordinate
 59+  8027 DD 23        			INC IX				; Increase HL to the next memory location
 60+  8029 DD 66 00     			LD H,(IX+0)			; Fetch the Y coordinate
 61+  802C DD 23        			INC IX				; Increase HL to the next memory location
 62+  802E CD 42 80     			CALL Get_Char_Address		; Calculate the screen address (in DE)
 63+  8031 DD 7E 00     Print_String_0:		LD A,(IX)			; Fetch the character to print
 64+  8034 DD 23        			INC IX				; Increase HL to the next character
 65+  8036 FE FE        			CP 0xFE				; Compare with 0xFE
 66+  8038 28 EA        			JR Z,Print_String		; If it is equal to 0xFE then loop back to print next string
 67+  803A D0           			RET NC				; If it is greater or equal to (carry bit set) then
 68+  803B CD D1 80     			CALL Print_Char			; Print the character
 69+  803E 2C           			INC L				; Go to the next screen address
 70+  803F 18 F0        			JR Print_String_0		; Loop back to print next character
 71+  8041 C9           			RET
 72+  8042
 73+  8042              ; Get screen address
 74+  8042              ; H = Y character position
 75+  8042              ; L = X character position
 76+  8042              ; Returns address in HL
 77+  8042              ;
 78+  8042 7C           Get_Char_Address:	LD A,H
 79+  8043 E6 07        			AND %00000111
 80+  8045 1F           			RRA
 81+  8046 1F           			RRA
 82+  8047 1F           			RRA
 83+  8048 1F           			RRA
 84+  8049 B5           			OR L
 85+  804A 6F           			LD L,A
 86+  804B 7C           			LD A,H
 87+  804C E6 18        			AND %00011000
 88+  804E F6 40        			OR %01000000
 89+  8050 67           			LD H,A
 90+  8051 C9           			RET				; Returns screen address in HL
 91+  8052
 92+  8052              ; Move HL down one character line
 93+  8052              ;
 94+  8052 7D           Char_Address_Down:	LD A, L
 95+  8053 C6 20        			ADD A, 32
 96+  8055 6F           			LD L, A
 97+  8056 D0           			RET NC
 98+  8057 7C           			LD A, H
 99+  8058 C6 08        			ADD A, 8
100+  805A 67           			LD H, A
101+  805B C9           			RET
102+  805C
103+  805C              ; Get screen address
104+  805C              ; B = Y pixel position
105+  805C              ; C = X pixel position
106+  805C              ; Returns address in HL and pixel position within character in A
107+  805C              ;
108+  805C 78           Get_Pixel_Address:	LD A,B				; Calculate Y2,Y1,Y0
109+  805D E6 07        			AND %00000111			; Mask out unwanted bits
110+  805F F6 40        			OR %01000000			; Set base address of screen
111+  8061 67           			LD H,A				; Store in H
112+  8062 78           			LD A,B				; Calculate Y7,Y6
113+  8063 1F           			RRA				; Shift to position
114+  8064 1F           			RRA
115+  8065 1F           			RRA
116+  8066 E6 18        			AND %00011000			; Mask out unwanted bits
117+  8068 B4           			OR H				; OR with Y2,Y1,Y0
118+  8069 67           			LD H,A				; Store in H
119+  806A 78           			LD A,B				; Calculate Y5,Y4,Y3
120+  806B 17           			RLA				; Shift to position
121+  806C 17           			RLA
122+  806D E6 E0        			AND %11100000			; Mask out unwanted bits
123+  806F 6F           			LD L,A				; Store in L
124+  8070 79           			LD A,C				; Calculate X4,X3,X2,X1,X0
125+  8071 1F           			RRA				; Shift into position
126+  8072 1F           			RRA
127+  8073 1F           			RRA
128+  8074 E6 1F        			AND %00011111			; Mask out unwanted bits
129+  8076 B5           			OR L				; OR with Y5,Y4,Y3
130+  8077 6F           			LD L,A				; Store in L
131+  8078 79           			LD A,C
132+  8079 E6 07        			AND 7
133+  807B C9           			RET
134+  807C
135+  807C              ; Move HL down one pixel line
136+  807C              ;
137+  807C 24           Pixel_Address_Down:	INC H				; Go down onto the next pixel line
138+  807D 7C           			LD A,H				; Check if we have gone onto next character boundary
139+  807E E6 07        			AND 7
140+  8080 C0           			RET NZ				; No, so skip the next bit
141+  8081 7D           			LD A,L				; Go onto the next character line
142+  8082 C6 20        			ADD A,32
143+  8084 6F           			LD L,A
144+  8085 D8           			RET C				; Check if we have gone onto next third of screen
145+  8086 7C           			LD A,H				; Yes, so go onto next third
146+  8087 D6 08        			SUB 8
147+  8089 67           			LD H,A
148+  808A C9           			RET
149+  808B
150+  808B              ; Move HL up one pixel line
151+  808B              ;
152+  808B 25           Pixel_Address_Up:	DEC H				; Go up onto the next pixel line
153+  808C 7C           			LD A,H				; Check if we have gone onto the next character boundary
154+  808D E6 07        			AND 7
155+  808F FE 07        			CP 7
156+  8091 6F           			LD L,A
157+  8092 D8           			RET C
158+  8093 7C           			LD A,H
159+  8094 C6 08        			ADD A,8
160+  8096 67           			LD H,A
161+  8097 C9           			RET
162+  8098
163+  8098              ; Print a single BCD value
164+  8098              ;  A: Character to print
165+  8098              ; HL: Screen address to print character at
166+  8098              ;
167+  8098 DD 7E 00     Print_BCD_8		LD A, (IX)
167+  809B DD 23          INC IX
167+  809D CD B5 80       CALL Print_BCD
168+  80A0 DD 7E 00     Print_BCD_6		LD A, (IX)
168+  80A3 DD 23          INC IX
168+  80A5 CD B5 80       CALL Print_BCD
169+  80A8 DD 7E 00     Print_BCD_4		LD A, (IX)
169+  80AB DD 23          INC IX
169+  80AD CD B5 80       CALL Print_BCD
170+  80B0 DD 7E 00     Print_BCD_2		LD A, (IX)
170+  80B3 DD 23          INC IX
171+  80B5 F5           Print_BCD:		PUSH AF				; Store the value
172+  80B6 E6 F0        			AND 0xF0			; Get the top nibble
173+  80B8 1F           			RRA				; Shift into bottom nibble
174+  80B9 1F           			RRA
175+  80BA 1F           			RRA
176+  80BB 1F           			RRA
177+  80BC C6 30        			ADD A, '0'			; Add to ASCII '0'
178+  80BE CD D1 80     			CALL Print_Char			; Print the character
179+  80C1 2C           			INC L				; Move right one space
180+  80C2 F1           			POP AF
181+  80C3 E6 0F        			AND 0x0F			; Get the bottom nibble
182+  80C5 C6 30        			ADD A, '0'			; Add to ASCII '0'
183+  80C7 CD D1 80     			CALL Print_Char			; Print
184+  80CA 2C           			INC L				; Move right one space
185+  80CB C9           			RET
186+  80CC
187+  80CC              ; Print a single character out to an X/Y position
188+  80CC              ;  A: Character to print
189+  80CC              ;  C: X Coordinate
190+  80CC              ;  B: Y Coordinate
191+  80CC              ; DE: Address of character set
192+  80CC              ;
193+  80CC F5           Print_Char_At:		PUSH AF
194+  80CD CD 42 80     			CALL Get_Char_Address
195+  80D0 F1           			POP AF				; Fall through to Print_Char
196+  80D1              ;
197+  80D1              ; Print a single character out to a screen address
198+  80D1              ;  A:  Character to print
199+  80D1              ;  HL: Screen address to print character at
200+  80D1              ;  DE: Address of character set (if entering at Print_Char_UDG)
201+  80D1              ; No SM code here - needs to be re-enterent if called on interrupt
202+  80D1              ;
203+  80D1 11 00 3C     Print_Char:		LD DE, 0x3C00			; Address of character set in ROM
204+  80D4 E5           			PUSH HL
205+  80D5 06 00        			LD B, 0				; Get index into character set
206+  80D7 4F           			LD C, A
207+  80D8              			DUP 3
208+  80D8 CB 21       >			SLA C
209+  80DA CB 10       >			RL B
208+  80DC CB 21       >			SLA C
209+  80DE CB 10       >			RL B
208+  80E0 CB 21       >			SLA C
209+  80E2 CB 10       >			RL B
210+  80E4              			EDUP
211+  80E4 EB           			EX DE, HL
212+  80E5 09           			ADD HL, BC
213+  80E6 EB           			EX DE, HL
214+  80E7 CD EC 80     			CALL Print_UDG8
215+  80EA E1           			POP HL
216+  80EB C9           			RET
217+  80EC
218+  80EC              ; Print a UDG (Single Height)
219+  80EC              ; DE - Character data
220+  80EC              ; HL - Screen address
221+  80EC              ;
222+  80EC 06 08        Print_UDG8:		LD B,8				; Loop counter
223+  80EE 1A           2:			LD A,(DE)			; Get the byte from the ROM into A
224+  80EF 77           			LD (HL),A			; Stick A onto the screen
225+  80F0 13           			INC DE				; Goto next byte of character
226+  80F1 24           			INC H				; Goto next line on screen
227+  80F2 10 FA        			DJNZ 2B				; Loop around whilst it is Not Zero (NZ)
228+  80F4 C9           			RET
229+  80F5
# file closed: ./lib/output.z80
  6   80F5
  7   80F5                  include "./track.asm"
# file opened: ./track.asm
  1+  80F5              ; TRACK DRAWING
  2+  80F5
  3+  80F5              ; fills out the area that will be next to the track
  4+  80F5              PrepTrack:
  5+  80F5 06 00            ld b, 0
  6+  80F7 0E 60            ld c, 96 ; 12 * 8 (8 "pixels" per block)
  7+  80F9 CD 34 82         call GetAttrAddress
  8+  80FC
  9+  80FC 0E 20            ld c, 32
 10+  80FE 06 0C            ld b, 12
 11+  8100 3E 3F            ld a, %00111111 ; "dark" white = gray
 12+  8102 CD 14 80         call Fill_Attr
 13+  8105 C9               ret
 14+  8106
 15+  8106 00           TrackPaletteOffset: db 0 ; 0, 1 or 2
 16+  8107
 17+  8107              ; Update the palette offset
 18+  8107              TrackPaletteTick:
 19+  8107 3A 06 81         ld a, (TrackPaletteOffset)
 20+  810A 3C               inc a ; increment
 21+  810B FE 03            cp 3 ; if a == 3, Z = true
 22+  810D 20 02            jr nz, TrackPaletteTickDone
 23+  810F
 24+  810F                  ; uh oh! offset = 3!! oopsies!
 25+  810F 3E 00            ld a, 0
 26+  8111
 27+  8111              TrackPaletteTickDone:
 28+  8111 32 06 81         ld (TrackPaletteOffset), a ; put back
 29+  8114 C9               ret
 30+  8115
 31+  8115              FillTrackStart:
 32+  8115 06 0C            ld b, 12 ; b is the loop counter
 33+  8117              FillTrackLoop:
 34+  8117 CD 2C 81         call FillTrackLoopBody
 35+  811A
 36+  811A 10 FB            djnz FillTrackLoop ; loop back if b != 0
 37+  811C
 38+  811C C9               ret
 39+  811D
 40+  811D              ; track colors!
 41+  811D 52           TrackPalette: db %01010010 ; red
 42+  811E 76                         db %01110110 ; yellow
 43+  811F 64                         db %01100100 ; green
 44+  8120 52                         db %01010010 ; repeating, so that i don't need modulo
 45+  8121 76                         db %01110110
 46+  8122 64                         db %01100100
 47+  8123 52                         db %01010010
 48+  8124 76                         db %01110110
 49+  8125 64                         db %01100100
 50+  8126 52                         db %01010010
 51+  8127 76                         db %01110110
 52+  8128 64                         db %01100100
 53+  8129 52                         db %01010010
 54+  812A 76                         db %01110110
 55+  812B 64                         db %01100100
 56+  812C
 57+  812C              FillTrackLoopBody:
 58+  812C C5               push bc ; this puts b (and c) onto the stack
 59+  812D                          ; that will preserve the loop counter
 60+  812D
 61+  812D                  ; Calculating the Y position of the track block
 62+  812D 78               ld a, b
 63+  812E 17               rla ; multiply by 8 by rotating left 3 times
 64+  812F 17               rla
 65+  8130 17               rla
 66+  8131 C6 58            add 88
 67+  8133 4F               ld c, a
 68+  8134
 69+  8134                  ; Calculating the X position of the track block
 70+  8134 3E 0C            ld a, 12
 71+  8136 90               sub b
 72+  8137 47               ld b, a
 73+  8138
 74+  8138 CD 34 82         call GetAttrAddress
 75+  813B
 76+  813B                  ; Pick the color from the palette based on X
 77+  813B E5               push hl ; hl has the address!!
 78+  813C 21 1D 81         ld hl, TrackPalette
 79+  813F 7D               ld a, l ; manipulation time!
 80+  8140 80               add b ; different colors!
 81+  8141
 82+  8141                  ; Adding the "offset"
 83+  8141 E5               push hl
 84+  8142 2A 06 81         ld hl, (TrackPaletteOffset)
 85+  8145 85               add l ; offset!
 86+  8146 E1               pop hl
 87+  8147
 88+  8147 6F               ld l, a
 89+  8148 7E               ld a, (hl)
 90+  8149 E1               pop hl ; oof!
 91+  814A F5               push af ; store the color for a sec
 92+  814B
 93+  814B                  ; Calculating the width
 94+  814B                  ; Width = 32 - x - x (x = "margin")
 95+  814B 3E 20            ld a, 32
 96+  814D 90               sub b
 97+  814E 90               sub b
 98+  814F 4F               ld c, a
 99+  8150                  ; Height = 1
100+  8150 06 01            ld b, 1
101+  8152
102+  8152 F1               pop af ; get that color back
103+  8153 CD 14 80         call Fill_Attr
104+  8156
105+  8156 C1               pop bc ; bring back the loop counter
106+  8157 C9               ret
# file closed: ./track.asm
  8   8158                  include "./sky.asm"
# file opened: ./sky.asm
  1+  8158              ; Draws the sky "gradient"
  2+  8158              PrepSky:
  3+  8158 06 00            ld b, 0
  4+  815A 0E 58            ld c, 88
  5+  815C CD 34 82         call GetAttrAddress ; HL = address
  6+  815F
  7+  815F 0E 20            ld c, 32 ; width
  8+  8161 06 01            ld b, 1 ; height
  9+  8163 3E 48            ld a, %01001000 ; bright blue
 10+  8165 CD 14 80         call Fill_Attr
 11+  8168
 12+  8168 06 00            ld b, 0
 13+  816A 0E 50            ld c, 80
 14+  816C CD 34 82         call GetAttrAddress ; HL = address
 15+  816F
 16+  816F 0E 20            ld c, 32 ; width
 17+  8171 06 01            ld b, 1 ; height
 18+  8173 3E 08            ld a, %00001000 ; dark blue
 19+  8175 CD 14 80         call Fill_Attr
 20+  8178
 21+  8178 CD 9C 81         call DrawMoon
 22+  817B
 23+  817B C9               ret
 24+  817C
 25+  817C              ; Moon sprites
 26+  817C 07           MoonSprite00: db %00000111
 27+  817D 1F                         db %00011111
 28+  817E 3F                         db %00111111
 29+  817F 7F                         db %01111111
 30+  8180 7F                         db %01111111
 31+  8181 FE                         db %11111110
 32+  8182 FE                         db %11111110
 33+  8183 FE                         db %11111110
 34+  8184 C0           MoonSprite01: db %11000000
 35+  8185 F0                         db %11110000
 36+  8186 F8                         db %11111000
 37+  8187 FC                         db %11111100
 38+  8188 04                         db %00000100
 39+  8189 02                         db %00000010
 40+  818A 00                         db %00000000
 41+  818B 00                         db %00000000
 42+  818C FE           MoonSprite10: db %11111110
 43+  818D FE                         db %11111110
 44+  818E 7F                         db %01111111
 45+  818F 7F                         db %01111111
 46+  8190 3F                         db %00111111
 47+  8191 1F                         db %00011111
 48+  8192 07                         db %00000111
 49+  8193 00                         db %00000000
 50+  8194 00           MoonSprite11: db %00000000
 51+  8195 02                         db %00000010
 52+  8196 04                         db %00000100
 53+  8197 FC                         db %11111100
 54+  8198 F8                         db %11111000
 55+  8199 F0                         db %11110000
 56+  819A C0                         db %11000000
 57+  819B 00                         db %00000000
 58+  819C
 59+  819C              DrawMoon:
 60+  819C 21 7C 81         ld hl, MoonSprite00
 61+  819F 06 02            ld b, 2
 62+  81A1 0E 10            ld c, 16
 63+  81A3 CD 46 82         call GetScreenPos
 64+  81A6 CD 6B 82         call DrawSprite
 65+  81A9
 66+  81A9 21 84 81         ld hl, MoonSprite01
 67+  81AC 06 03            ld b, 3
 68+  81AE 0E 10            ld c, 16
 69+  81B0 CD 46 82         call GetScreenPos
 70+  81B3 CD 6B 82         call DrawSprite
 71+  81B6
 72+  81B6 21 8C 81         ld hl, MoonSprite10
 73+  81B9 06 02            ld b, 2
 74+  81BB 0E 18            ld c, 24
 75+  81BD CD 46 82         call GetScreenPos
 76+  81C0 CD 6B 82         call DrawSprite
 77+  81C3
 78+  81C3 21 94 81         ld hl, MoonSprite11
 79+  81C6 06 03            ld b, 3
 80+  81C8 0E 18            ld c, 24
 81+  81CA CD 46 82         call GetScreenPos
 82+  81CD CD 6B 82         call DrawSprite
 83+  81D0
 84+  81D0 C9               ret
# file closed: ./sky.asm
  9   81D1
 10   81D1              Main:
 11   81D1                  ; pain incoming
 12   81D1 CD 2B 82         call PrepScreen
 13   81D4 CD F5 80         call PrepTrack
 14   81D7 CD 58 81         call PrepSky
 15   81DA
 16   81DA CD 1A 82         call FillTurnBack
 17   81DD CD 12 82         call DrawString
 18   81E0
 19   81E0 CD E5 81         call AnimLoop
 20   81E3 C9               ret
 21   81E4
 22   81E4 50           AnimTickDelay: db 80 ; delay for tick updates
 23   81E5
 24   81E5              ; Animation loop!
 25   81E5              AnimLoop:
 26   81E5 CD 15 81         call FillTrackStart
 27   81E8
 28   81E8                  ; This calms the tick updates by spacing them out
 29   81E8 3A E4 81         ld a, (AnimTickDelay)
 30   81EB FE 00            cp 0
 31   81ED 20 08            jr nz, AnimLoopDone
 32   81EF 3E 50            ld a, 80
 33   81F1 32 E4 81         ld (AnimTickDelay), a
 34   81F4
 35   81F4                  ; Tick updates
 36   81F4 CD 07 81         call TrackPaletteTick
 37   81F7
 38   81F7              AnimLoopDone:
 39   81F7 3A E4 81         ld a, (AnimTickDelay)
 40   81FA 3D               dec a
 41   81FB 32 E4 81         ld (AnimTickDelay), a
 42   81FE
 43   81FE C3 E5 81         jp AnimLoop
 44   8201
 45   8201              ; Draws the * TURN BACK * text
 46   8201 09 00 2A 20  TurnBackStr: db $9, $0, "* TURN  BACK *", $FF
 46   8205 54 55 52 4E
 46   8209 20 20 42 41
 46   820D 43 4B 20 2A
 46   8211 FF
 47   8212              DrawString:
 48   8212 DD 21 01 82      ld ix, TurnBackStr
 49   8216 CD 24 80         call Print_String
 50   8219 C9               ret
 51   821A
 52   821A              FillTurnBack:
 53   821A 06 08            ld b, 8
 54   821C 0E 00            ld c, 0
 55   821E CD 34 82         call GetAttrAddress ; HL = address
 56   8221
 57   8221 0E 10            ld c, 16 ; width
 58   8223 06 01            ld b, 1 ; height
 59   8225 3E C2            ld a, %11000010 ; bright red, flashing
 60   8227 CD 14 80         call Fill_Attr
 61   822A C9               ret
 62   822B
 63   822B              ; fill screen with black
 64   822B              PrepScreen:
 65   822B 3E 47            ld a, %01000111 ; black, white "ink"
 66   822D CD 00 80         call Clear_Screen
 67   8230 CD 9B 22         call 8859 ; border color
 68   8233 C9               ret
 69   8234
 70   8234              ; Get address of block in attribute map
 71   8234              ; BC - XY
 72   8234              ; address -> HL
 73   8234              ; https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
 74   8234              GetAttrAddress:
 75   8234 79               ld a, C
 76   8235 E6 C0                and %11000000
 77   8237 07                   rlca
 78   8238 07                   rlca
 79   8239 C6 58                add $58
 80   823B 57                   ld d, a
 81   823C 79               ld a, C
 82   823D E6 38            and %00111000
 83   823F 07               rlca
 84   8240 07               rlca
 85   8241
 86   8241 80               add b
 87   8242 5F               ld e, a
 88   8243
 89   8243 D5               push de
 90   8244 E1               pop hl
 91   8245 C9               ret
 92   8246
 93   8246              ; Get sprite address
 94   8246              ; BC - XY
 95   8246              ; DE - address
 96   8246              ; https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
 97   8246              GetScreenPos:
 98   8246 79               ld a, c
 99   8247 E6 38            and %00111000
100   8249 07               rlca
101   824A 07               rlca
102   824B B0               or b
103   824C 5F               ld e, a
104   824D 79               ld a, c
105   824E E6 07            and %00000111
106   8250 57               ld d, a
107   8251 79               ld a, c
108   8252 E6 C0            and %11000000
109   8254 0F               rrca
110   8255 0F               rrca
111   8256 0F               rrca
112   8257 B2               or d
113   8258 F6 40            or $40
114   825A 57               ld d, a
115   825B C9               ret
116   825C
117   825C              ; Moves DE down a line
118   825C              ; https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
119   825C              GetNextLine:
120   825C 14               inc d
121   825D 7A               ld a, d
122   825E E6 07            and %00000111
123   8260 C0               ret nz
124   8261 7B               ld a, e
125   8262 C6 20            add a, %00100000
126   8264 5F               ld e, a
127   8265 D8               ret c
128   8266 7A               ld a, d
129   8267 D6 08            sub %00001000
130   8269 57               ld d, a
131   826A C9               ret
132   826B
133   826B              ; HL - sprite address
134   826B              ; DE - position address
135   826B              ; https://www.chibiakumas.com/z80/simplesamples.php#LessonS2
136   826B              DrawSprite:
137   826B 06 08            ld b, 8
138   826D              SpriteNextLine:
139   826D 7E               ld a, (hl)
140   826E 12               ld (de), a
141   826F 23               inc hl
142   8270
143   8270 CD 5C 82         call GetNextLine
144   8273 10 F8            djnz SpriteNextLine
145   8275
146   8275 C9               ret
147   8276
148   8276                  savesna "./main.sna", Main
# file closed: main.asm

Value    Label
------ - -----------------------------------------------------------
0x8000   Clear_Screen
0x8014   Fill_Attr
0x8024   Print_String
0x8042   Get_Char_Address
0x8031   Print_String_0
0x80D1   Print_Char
0x8052 X Char_Address_Down
0x805C X Get_Pixel_Address
0x807C X Pixel_Address_Down
0x808B X Pixel_Address_Up
0x8098 X Print_BCD_8
0x80B5   Print_BCD
0x80A0 X Print_BCD_6
0x80A8 X Print_BCD_4
0x80B0 X Print_BCD_2
0x80CC X Print_Char_At
0x80EC   Print_UDG8
0x80F5   PrepTrack
0x8234   GetAttrAddress
0x8106   TrackPaletteOffset
0x8107   TrackPaletteTick
0x8111   TrackPaletteTickDone
0x8115   FillTrackStart
0x8117   FillTrackLoop
0x812C   FillTrackLoopBody
0x811D   TrackPalette
0x8158   PrepSky
0x819C   DrawMoon
0x817C   MoonSprite00
0x8184   MoonSprite01
0x818C   MoonSprite10
0x8194   MoonSprite11
0x8246   GetScreenPos
0x826B   DrawSprite
0x81D1 X Main
0x822B   PrepScreen
0x821A   FillTurnBack
0x8212   DrawString
0x81E5   AnimLoop
0x81E4   AnimTickDelay
0x81F7   AnimLoopDone
0x8201   TurnBackStr
0x825C   GetNextLine
0x826D   SpriteNextLine
